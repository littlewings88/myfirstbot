{
  "name": "project-oxford",
  "version": "1.5.0",
  "description": "Vision, and Face Intelligence with Project Oxford",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/felixrieseberg/project-oxford.git"
  },
  "main": "dist/oxford.js",
  "scripts": {
    "test": "mocha --reporter spec",
    "docs": "jsdoc2md dist/*.js > api.md",
    "build": "grunt compile"
  },
  "author": {
    "name": "Felix Rieseberg"
  },
  "license": "MIT",
  "dependencies": {
    "bluebird": "^2.9.34",
    "request": "^2.60.0"
  },
  "devDependencies": {
    "chai": "^3.2.0",
    "grunt": "^0.4.5",
    "grunt-babel": "^5.0.1",
    "grunt-contrib-clean": "^0.6.0",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-jscodesniffer": "^0.1.8",
    "grunt-jscs": "^0.8.1",
    "grunt-jsdoc-to-markdown": "^1.2.1",
    "load-grunt-tasks": "^1.0.0",
    "mocha": "^2.2.5",
    "uuid": "^2.0.1"
  },
  "browser": {
    "net": false,
    "fs": false
  },
  "readme": "## Project Oxford for Node.js\r\n[![npm version](https://badge.fury.io/js/project-oxford.svg)](http://badge.fury.io/js/project-oxford)\r\n[![Build Status](https://travis-ci.org/felixrieseberg/project-oxford.svg?branch=master)](https://travis-ci.org/felixrieseberg/project-oxford)\r\n\r\nThis package contains a set of intelligent APIs understanding images: It can detect and analyze people's faces, their age, gender, and similarity. It can identify people based on a set of images. It can understand what is displayed in a picture and crop it according to where the important features are. It can tell you whether an image contains adult content, what the main colors are, and which of your images belong in a group. If your image features text, it will tell you the language and return the text as a string. It's basically magic. For more details on the Project Oxford API, please visit [projectoxford.ai](http://www.projectoxford.ai/demo/face#detection).\r\n\r\nThis Node module implements Project Oxford's API for Faces, Vision, Text, Video, and WebLM.\r\n\r\n![](https://i.imgur.com/Zrsnhd3.jpg)\r\n\r\n## Usage\r\nTo install this package, run `npm install --save project-oxford` [and obtain an API key](http://www.projectoxford.ai/doc/general/subscription-key-mgmt). To obtain such a key, [you will also need an (free) Microsoft Azure Account](http://www.azure.com). Once you got your key, you can instantiate an Oxford client in your code:\r\n\r\n```\r\nvar oxford = require('project-oxford'),\r\n    client = new oxford.Client('7fb073s72bh72663y5ddh129m12e598d');\r\n```\r\n\r\nNow that you got your client running, you're ready to do some pretty smart stuff. Have a picture of a person and want a computed guess of their age and gender?\r\n\r\n```\r\nclient.face.detect({\r\n    path: 'myFolder/myFace.jpg',\r\n    analyzesAge: true,\r\n    analyzesGender: true\r\n}).then(function (response) {\r\n    console.log('The age is: ' + response[0].attributes.age);\r\n    console.log('The gender is: ' + response[0].attributes.gender);\r\n});\r\n```\r\nHave a picture of a person and want a computed guess about their emotions?\r\n\r\n```\r\nclient.emotion.analyzeEmotion({\r\n    path: './myFace.jpg',\r\n}).then(function (response) {\r\n    console.log(response);\r\n});\r\n```\r\nOr, you can add the rectangle of the face yourself, in the form \"left,top,width,height\". Delimited multiple face rectangles with a “;”.\r\n\r\n```\r\nclient.emotion.analyzeEmotion({\r\n    path: './myFace.jpg',\r\n    faceRectangles: '10, 10, 100, 100'\r\n}).then(function (response) {\r\n    console.log(response);\r\n});\r\n```\r\nCreating a smart-cropped thumbnail:\r\n```\r\nclient.vision.thumbnail({\r\n    path: './photo.jpg',\r\n    height: 150,\r\n    width: 150,\r\n    smartCropping: true,\r\n    pipe: fs.createWriteStream('./photo2.jpg')\r\n});\r\n```\r\n\r\nRunning OCR on an image, returning the text on the image:\r\n```\r\nclient.vision.ocr({\r\n    path: './test/images/ocr.jpg',\r\n    language: 'en'\r\n}).then(function (response) {\r\n    console.log(response.body);\r\n});\r\n```\r\n\r\nFor the full documentation, please see the API reference below.\r\n\r\n## API Reference\r\n\r\n## License\r\n<a name=\"Client\"></a>\r\n\r\n## Client\r\n**Kind**: global class  \r\n\r\n* [Client](#Client)\r\n    * [new Client(key, host)](#new_Client_new)\r\n    * [.emotion](#Client.emotion) : <code>object</code>\r\n        * [~analyzeEmotion(options)](#Client.emotion..analyzeEmotion) ⇒ <code>Promise</code>\r\n    * [.face](#Client.face) : <code>object</code>\r\n        * _static_\r\n            * [.faceList](#Client.face.faceList) : <code>object</code>\r\n                * [.list()](#Client.face.faceList.list) ⇒ <code>Promise</code>\r\n                * [.create(faceListId, options)](#Client.face.faceList.create) ⇒ <code>Promise</code>\r\n                * [.update(faceListId, options)](#Client.face.faceList.update) ⇒ <code>Promise</code>\r\n                * [.delete(faceListId)](#Client.face.faceList.delete) ⇒ <code>Promise</code>\r\n                * [.get(faceListId)](#Client.face.faceList.get) ⇒ <code>Promise</code>\r\n                * [.addFace(faceListId, options)](#Client.face.faceList.addFace) ⇒ <code>Promise</code>\r\n                * [.deleteFace(faceListId, persistedFaceId)](#Client.face.faceList.deleteFace) ⇒ <code>Promise</code>\r\n            * [.personGroup](#Client.face.personGroup) : <code>object</code>\r\n                * [.create(personGroupId, name, userData)](#Client.face.personGroup.create) ⇒ <code>Promise</code>\r\n                * [.delete(personGroupId)](#Client.face.personGroup.delete) ⇒ <code>Promise</code>\r\n                * [.get(personGroupId)](#Client.face.personGroup.get) ⇒ <code>Promise</code>\r\n                * [.trainingStatus(personGroupId)](#Client.face.personGroup.trainingStatus) ⇒ <code>Promise</code>\r\n                * [.trainingStart(personGroupId)](#Client.face.personGroup.trainingStart) ⇒ <code>Promise</code>\r\n                * [.update(personGroupId, name, userData)](#Client.face.personGroup.update) ⇒ <code>Promise</code>\r\n                * [.list()](#Client.face.personGroup.list) ⇒ <code>Promise</code>\r\n            * [.person](#Client.face.person) : <code>object</code>\r\n                * [.addFace(personGroupId, personId, options)](#Client.face.person.addFace) ⇒ <code>Promise</code>\r\n                * [.deleteFace(personGroupId, personId, persistedFaceId)](#Client.face.person.deleteFace) ⇒ <code>Promise</code>\r\n                * [.updateFace(personGroupId, personId, persistedFaceId, userData)](#Client.face.person.updateFace) ⇒ <code>Promise</code>\r\n                * [.getFace(personGroupId, personId, persistedFaceId)](#Client.face.person.getFace) ⇒ <code>Promise</code>\r\n                * [.create(personGroupId, name, userData)](#Client.face.person.create) ⇒ <code>Promise</code>\r\n                * [.delete(personGroupId, personId)](#Client.face.person.delete) ⇒ <code>Promise</code>\r\n                * [.get(personGroupId, personId)](#Client.face.person.get) ⇒ <code>Promise</code>\r\n                * [.update(personGroupId, name, userData)](#Client.face.person.update) ⇒ <code>Promise</code>\r\n                * [.list(personGroupId)](#Client.face.person.list) ⇒ <code>Promise</code>\r\n        * _inner_\r\n            * [~detect(options)](#Client.face..detect) ⇒ <code>Promise</code>\r\n            * [~similar(sourceFace, options)](#Client.face..similar) ⇒ <code>Promise</code>\r\n            * [~grouping(faces)](#Client.face..grouping) ⇒ <code>Promise</code>\r\n            * [~identify(faces, personGroupId, maxNumOfCandidatesReturned)](#Client.face..identify) ⇒ <code>Promise</code>\r\n            * [~verify(faces)](#Client.face..verify) ⇒ <code>Promise</code>\r\n    * [.text](#Client.text) : <code>object</code>\r\n        * [~proof(text, preContextText, postContextText)](#Client.text..proof) ⇒ <code>Promise</code>\r\n        * [~spellCheck(text, preContextText, postContextText)](#Client.text..spellCheck) ⇒ <code>Promise</code>\r\n    * [.video](#Client.video) : <code>object</code>\r\n        * _static_\r\n            * [.result](#Client.video.result)\r\n                * [.get(operation)](#Client.video.result.get) ⇒ <code>Promise</code>\r\n                * [.getVideo(url, pipe)](#Client.video.result.getVideo) ⇒ <code>Promise</code>\r\n        * _inner_\r\n            * [~trackFace(options)](#Client.video..trackFace) ⇒ <code>Promise</code>\r\n            * [~detectMotion(options)](#Client.video..detectMotion) ⇒ <code>Promise</code>\r\n            * [~stabilize(options)](#Client.video..stabilize) ⇒ <code>Promise</code>\r\n    * [.vision](#Client.vision) : <code>object</code>\r\n        * _static_\r\n            * [.models](#Client.vision.models) : <code>object</code>\r\n                * [.list()](#Client.vision.models.list) ⇒ <code>Promise</code>\r\n                * [.analyzeImage(model, options)](#Client.vision.models.analyzeImage) ⇒ <code>Promise</code>\r\n        * _inner_\r\n            * [~analyzeImage(options)](#Client.vision..analyzeImage) ⇒ <code>Promise</code>\r\n            * [~thumbnail(options)](#Client.vision..thumbnail) ⇒ <code>Promise</code>\r\n            * [~ocr(options)](#Client.vision..ocr) ⇒ <code>Promise</code>\r\n    * [.weblm](#Client.weblm) : <code>object</code>\r\n        * [~listModels()](#Client.weblm..listModels) ⇒ <code>Promise</code>\r\n        * [~breakIntoWords(model, text, options)](#Client.weblm..breakIntoWords) ⇒ <code>Promise</code>\r\n        * [~generateWords(model, words, options)](#Client.weblm..generateWords) ⇒ <code>Promise</code>\r\n        * [~getJointProbabilities(model, phrases, order)](#Client.weblm..getJointProbabilities) ⇒ <code>Promise</code>\r\n        * [~getConditionalProbabilities(model, queries, order)](#Client.weblm..getConditionalProbabilities) ⇒ <code>Promise</code>\r\n\r\n<a name=\"new_Client_new\"></a>\r\n\r\n### new Client(key, host)\r\nCreates a new Project Oxford Client using a given API key.\r\n\r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| key | <code>string</code> | Project Oxford API Key |\r\n| host | <code>string</code> | Optional host address |\r\n\r\n<a name=\"Client.emotion\"></a>\r\n\r\n### Client.emotion : <code>object</code>\r\n**Kind**: static namespace of <code>[Client](#Client)</code>  \r\n<a name=\"Client.emotion..analyzeEmotion\"></a>\r\n\r\n#### emotion~analyzeEmotion(options) ⇒ <code>Promise</code>\r\nAnalyze the emotions of one or more faces in an image.\r\n\r\n**Kind**: inner method of <code>[emotion](#Client.emotion)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| options | <code>Object</code> | Options object |\r\n| options.url | <code>string</code> | URL to the image file |\r\n| options.path | <code>string</code> | URL to a local image file |\r\n| options.faceRectangles | <code>Array.&lt;Object&gt;</code> | Array of face rectangles.  Face rectangles      are returned in the face.detect and vision.analyzeImage methods. |\r\n\r\n<a name=\"Client.face\"></a>\r\n\r\n### Client.face : <code>object</code>\r\n**Kind**: static namespace of <code>[Client](#Client)</code>  \r\n\r\n* [.face](#Client.face) : <code>object</code>\r\n    * _static_\r\n        * [.faceList](#Client.face.faceList) : <code>object</code>\r\n            * [.list()](#Client.face.faceList.list) ⇒ <code>Promise</code>\r\n            * [.create(faceListId, options)](#Client.face.faceList.create) ⇒ <code>Promise</code>\r\n            * [.update(faceListId, options)](#Client.face.faceList.update) ⇒ <code>Promise</code>\r\n            * [.delete(faceListId)](#Client.face.faceList.delete) ⇒ <code>Promise</code>\r\n            * [.get(faceListId)](#Client.face.faceList.get) ⇒ <code>Promise</code>\r\n            * [.addFace(faceListId, options)](#Client.face.faceList.addFace) ⇒ <code>Promise</code>\r\n            * [.deleteFace(faceListId, persistedFaceId)](#Client.face.faceList.deleteFace) ⇒ <code>Promise</code>\r\n        * [.personGroup](#Client.face.personGroup) : <code>object</code>\r\n            * [.create(personGroupId, name, userData)](#Client.face.personGroup.create) ⇒ <code>Promise</code>\r\n            * [.delete(personGroupId)](#Client.face.personGroup.delete) ⇒ <code>Promise</code>\r\n            * [.get(personGroupId)](#Client.face.personGroup.get) ⇒ <code>Promise</code>\r\n            * [.trainingStatus(personGroupId)](#Client.face.personGroup.trainingStatus) ⇒ <code>Promise</code>\r\n            * [.trainingStart(personGroupId)](#Client.face.personGroup.trainingStart) ⇒ <code>Promise</code>\r\n            * [.update(personGroupId, name, userData)](#Client.face.personGroup.update) ⇒ <code>Promise</code>\r\n            * [.list()](#Client.face.personGroup.list) ⇒ <code>Promise</code>\r\n        * [.person](#Client.face.person) : <code>object</code>\r\n            * [.addFace(personGroupId, personId, options)](#Client.face.person.addFace) ⇒ <code>Promise</code>\r\n            * [.deleteFace(personGroupId, personId, persistedFaceId)](#Client.face.person.deleteFace) ⇒ <code>Promise</code>\r\n            * [.updateFace(personGroupId, personId, persistedFaceId, userData)](#Client.face.person.updateFace) ⇒ <code>Promise</code>\r\n            * [.getFace(personGroupId, personId, persistedFaceId)](#Client.face.person.getFace) ⇒ <code>Promise</code>\r\n            * [.create(personGroupId, name, userData)](#Client.face.person.create) ⇒ <code>Promise</code>\r\n            * [.delete(personGroupId, personId)](#Client.face.person.delete) ⇒ <code>Promise</code>\r\n            * [.get(personGroupId, personId)](#Client.face.person.get) ⇒ <code>Promise</code>\r\n            * [.update(personGroupId, name, userData)](#Client.face.person.update) ⇒ <code>Promise</code>\r\n            * [.list(personGroupId)](#Client.face.person.list) ⇒ <code>Promise</code>\r\n    * _inner_\r\n        * [~detect(options)](#Client.face..detect) ⇒ <code>Promise</code>\r\n        * [~similar(sourceFace, options)](#Client.face..similar) ⇒ <code>Promise</code>\r\n        * [~grouping(faces)](#Client.face..grouping) ⇒ <code>Promise</code>\r\n        * [~identify(faces, personGroupId, maxNumOfCandidatesReturned)](#Client.face..identify) ⇒ <code>Promise</code>\r\n        * [~verify(faces)](#Client.face..verify) ⇒ <code>Promise</code>\r\n\r\n<a name=\"Client.face.faceList\"></a>\r\n\r\n#### face.faceList : <code>object</code>\r\n**Kind**: static namespace of <code>[face](#Client.face)</code>  \r\n\r\n* [.faceList](#Client.face.faceList) : <code>object</code>\r\n    * [.list()](#Client.face.faceList.list) ⇒ <code>Promise</code>\r\n    * [.create(faceListId, options)](#Client.face.faceList.create) ⇒ <code>Promise</code>\r\n    * [.update(faceListId, options)](#Client.face.faceList.update) ⇒ <code>Promise</code>\r\n    * [.delete(faceListId)](#Client.face.faceList.delete) ⇒ <code>Promise</code>\r\n    * [.get(faceListId)](#Client.face.faceList.get) ⇒ <code>Promise</code>\r\n    * [.addFace(faceListId, options)](#Client.face.faceList.addFace) ⇒ <code>Promise</code>\r\n    * [.deleteFace(faceListId, persistedFaceId)](#Client.face.faceList.deleteFace) ⇒ <code>Promise</code>\r\n\r\n<a name=\"Client.face.faceList.list\"></a>\r\n\r\n##### faceList.list() ⇒ <code>Promise</code>\r\nLists the faceListIds, and associated names and/or userData.\r\n\r\n**Kind**: static method of <code>[faceList](#Client.face.faceList)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n<a name=\"Client.face.faceList.create\"></a>\r\n\r\n##### faceList.create(faceListId, options) ⇒ <code>Promise</code>\r\nCreates a new face list with a user-specified ID.\r\nA face list is a list of faces associated to be associated with a given person.\r\n\r\n**Kind**: static method of <code>[faceList](#Client.face.faceList)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| faceListId | <code>string</code> | Numbers, en-us letters in lower case, '-', '_'. Max length: 64 |\r\n| options | <code>object</code> | Optional parameters |\r\n| options.name | <code>string</code> | Name of the face List |\r\n| options.userData | <code>string</code> | User-provided data associated with the face list. |\r\n\r\n<a name=\"Client.face.faceList.update\"></a>\r\n\r\n##### faceList.update(faceListId, options) ⇒ <code>Promise</code>\r\nCreates a new person group with a user-specified ID.\r\nA person group is one of the most important parameters for the Identification API.\r\nThe Identification searches person faces in a specified person group.\r\n\r\n**Kind**: static method of <code>[faceList](#Client.face.faceList)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| faceListId | <code>string</code> | Numbers, en-us letters in lower case, '-', '_'. Max length: 64 |\r\n| options | <code>object</code> | Optional parameters |\r\n| options.name | <code>string</code> | Name of the face List |\r\n| options.userData | <code>string</code> | User-provided data associated with the face list. |\r\n\r\n<a name=\"Client.face.faceList.delete\"></a>\r\n\r\n##### faceList.delete(faceListId) ⇒ <code>Promise</code>\r\nDeletes an existing person group.\r\n\r\n**Kind**: static method of <code>[faceList](#Client.face.faceList)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| faceListId | <code>string</code> | ID of face list to delete |\r\n\r\n<a name=\"Client.face.faceList.get\"></a>\r\n\r\n##### faceList.get(faceListId) ⇒ <code>Promise</code>\r\nGets an existing face list.\r\n\r\n**Kind**: static method of <code>[faceList](#Client.face.faceList)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| faceListId | <code>string</code> | ID of face list to retrieve |\r\n\r\n<a name=\"Client.face.faceList.addFace\"></a>\r\n\r\n##### faceList.addFace(faceListId, options) ⇒ <code>Promise</code>\r\nGets an existing face list.\r\n\r\n**Kind**: static method of <code>[faceList](#Client.face.faceList)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| faceListId | <code>string</code> | ID of face list to retrieve |\r\n| options | <code>object</code> | Options object |\r\n| options.url | <code>string</code> | URL to image to be used |\r\n| options.path | <code>string</code> | Path to image to be used |\r\n| options.data | <code>string</code> | Image as a binary buffer |\r\n| options.name | <code>string</code> | Optional name for the face |\r\n| options.userData | <code>string</code> | Optional user-data for the face |\r\n| options.targetFace | <code>string</code> | Optional face rectangle to specify the target face to be added into the face list, in the format of \"targetFace=left,top,width,height\". |\r\n\r\n<a name=\"Client.face.faceList.deleteFace\"></a>\r\n\r\n##### faceList.deleteFace(faceListId, persistedFaceId) ⇒ <code>Promise</code>\r\nDelete a face from the face list.  The face ID will be an ID returned in the addFace method,\r\nnot from the detect method.\r\n\r\n**Kind**: static method of <code>[faceList](#Client.face.faceList)</code>  \r\n**Returns**: <code>Promise</code> - - Promise; successful response is empty  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| faceListId | <code>string</code> | ID of face list to retrieve |\r\n| persistedFaceId | <code>string</code> | ID of face in the face list |\r\n\r\n<a name=\"Client.face.personGroup\"></a>\r\n\r\n#### face.personGroup : <code>object</code>\r\n**Kind**: static namespace of <code>[face](#Client.face)</code>  \r\n\r\n* [.personGroup](#Client.face.personGroup) : <code>object</code>\r\n    * [.create(personGroupId, name, userData)](#Client.face.personGroup.create) ⇒ <code>Promise</code>\r\n    * [.delete(personGroupId)](#Client.face.personGroup.delete) ⇒ <code>Promise</code>\r\n    * [.get(personGroupId)](#Client.face.personGroup.get) ⇒ <code>Promise</code>\r\n    * [.trainingStatus(personGroupId)](#Client.face.personGroup.trainingStatus) ⇒ <code>Promise</code>\r\n    * [.trainingStart(personGroupId)](#Client.face.personGroup.trainingStart) ⇒ <code>Promise</code>\r\n    * [.update(personGroupId, name, userData)](#Client.face.personGroup.update) ⇒ <code>Promise</code>\r\n    * [.list()](#Client.face.personGroup.list) ⇒ <code>Promise</code>\r\n\r\n<a name=\"Client.face.personGroup.create\"></a>\r\n\r\n##### personGroup.create(personGroupId, name, userData) ⇒ <code>Promise</code>\r\nCreates a new person group with a user-specified ID.\r\nA person group is one of the most important parameters for the Identification API.\r\nThe Identification searches person faces in a specified person group.\r\n\r\n**Kind**: static method of <code>[personGroup](#Client.face.personGroup)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | Numbers, en-us letters in lower case, '-', '_'. Max length: 64 |\r\n| name | <code>string</code> | Person group display name. The maximum length is 128. |\r\n| userData | <code>string</code> | User-provided data attached to the group. The size limit is 16KB. |\r\n\r\n<a name=\"Client.face.personGroup.delete\"></a>\r\n\r\n##### personGroup.delete(personGroupId) ⇒ <code>Promise</code>\r\nDeletes an existing person group.\r\n\r\n**Kind**: static method of <code>[personGroup](#Client.face.personGroup)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | Name of person group to delete |\r\n\r\n<a name=\"Client.face.personGroup.get\"></a>\r\n\r\n##### personGroup.get(personGroupId) ⇒ <code>Promise</code>\r\nGets an existing person group.\r\n\r\n**Kind**: static method of <code>[personGroup](#Client.face.personGroup)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | Name of person group to get |\r\n\r\n<a name=\"Client.face.personGroup.trainingStatus\"></a>\r\n\r\n##### personGroup.trainingStatus(personGroupId) ⇒ <code>Promise</code>\r\nRetrieves the training status of a person group. Training is triggered by the Train PersonGroup API.\r\nThe training will process for a while on the server side. This API can query whether the training\r\nis completed or ongoing.\r\n\r\n**Kind**: static method of <code>[personGroup](#Client.face.personGroup)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | Name of person group to get |\r\n\r\n<a name=\"Client.face.personGroup.trainingStart\"></a>\r\n\r\n##### personGroup.trainingStart(personGroupId) ⇒ <code>Promise</code>\r\nStarts a person group training.\r\nTraining is a necessary preparation process of a person group before identification.\r\nEach person group needs to be trained in order to call Identification. The training\r\nwill process for a while on the server side even after this API has responded.\r\n\r\n**Kind**: static method of <code>[personGroup](#Client.face.personGroup)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | Name of person group to get |\r\n\r\n<a name=\"Client.face.personGroup.update\"></a>\r\n\r\n##### personGroup.update(personGroupId, name, userData) ⇒ <code>Promise</code>\r\nUpdates an existing person group's display name and userData.\r\n\r\n**Kind**: static method of <code>[personGroup](#Client.face.personGroup)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | Numbers, en-us letters in lower case, '-', '_'. Max length: 64 |\r\n| name | <code>string</code> | Person group display name. The maximum length is 128. |\r\n| userData | <code>string</code> | User-provided data attached to the group. The size limit is 16KB. |\r\n\r\n<a name=\"Client.face.personGroup.list\"></a>\r\n\r\n##### personGroup.list() ⇒ <code>Promise</code>\r\nLists all person groups in the current subscription.\r\n\r\n**Kind**: static method of <code>[personGroup](#Client.face.personGroup)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n<a name=\"Client.face.person\"></a>\r\n\r\n#### face.person : <code>object</code>\r\n**Kind**: static namespace of <code>[face](#Client.face)</code>  \r\n\r\n* [.person](#Client.face.person) : <code>object</code>\r\n    * [.addFace(personGroupId, personId, options)](#Client.face.person.addFace) ⇒ <code>Promise</code>\r\n    * [.deleteFace(personGroupId, personId, persistedFaceId)](#Client.face.person.deleteFace) ⇒ <code>Promise</code>\r\n    * [.updateFace(personGroupId, personId, persistedFaceId, userData)](#Client.face.person.updateFace) ⇒ <code>Promise</code>\r\n    * [.getFace(personGroupId, personId, persistedFaceId)](#Client.face.person.getFace) ⇒ <code>Promise</code>\r\n    * [.create(personGroupId, name, userData)](#Client.face.person.create) ⇒ <code>Promise</code>\r\n    * [.delete(personGroupId, personId)](#Client.face.person.delete) ⇒ <code>Promise</code>\r\n    * [.get(personGroupId, personId)](#Client.face.person.get) ⇒ <code>Promise</code>\r\n    * [.update(personGroupId, name, userData)](#Client.face.person.update) ⇒ <code>Promise</code>\r\n    * [.list(personGroupId)](#Client.face.person.list) ⇒ <code>Promise</code>\r\n\r\n<a name=\"Client.face.person.addFace\"></a>\r\n\r\n##### person.addFace(personGroupId, personId, options) ⇒ <code>Promise</code>\r\nAdds a face to a person for identification. The maximum face count for each person is 248.\r\n\r\n**Kind**: static method of <code>[person](#Client.face.person)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | The target person's person group. |\r\n| personId | <code>string</code> | The target person that the face is added to. |\r\n| options | <code>object</code> | The source specification. |\r\n| options.url | <code>string</code> | URL to image to be used. |\r\n| options.path | <code>string</code> | Path to image to be used. |\r\n| options.data | <code>string</code> | Image as a binary buffer |\r\n| options.userData | <code>string</code> | Optional. Attach user data to person's face. The maximum length is 1024. |\r\n| options.targetFace | <code>object</code> | Optional. The rectangle of the face in the image. |\r\n\r\n<a name=\"Client.face.person.deleteFace\"></a>\r\n\r\n##### person.deleteFace(personGroupId, personId, persistedFaceId) ⇒ <code>Promise</code>\r\nDeletes a face from a person.\r\n\r\n**Kind**: static method of <code>[person](#Client.face.person)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | The target person's person group. |\r\n| personId | <code>string</code> | The target person that the face is removed from. |\r\n| persistedFaceId | <code>string</code> | The ID of the face to be deleted. |\r\n\r\n<a name=\"Client.face.person.updateFace\"></a>\r\n\r\n##### person.updateFace(personGroupId, personId, persistedFaceId, userData) ⇒ <code>Promise</code>\r\nUpdates a face for a person.\r\n\r\n**Kind**: static method of <code>[person](#Client.face.person)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | The target person's person group. |\r\n| personId | <code>string</code> | The target person that the face is updated on. |\r\n| persistedFaceId | <code>string</code> | The ID of the face to be updated. |\r\n| userData | <code>string</code> | Optional. Attach user data to person's face. The maximum length is 1024. |\r\n\r\n<a name=\"Client.face.person.getFace\"></a>\r\n\r\n##### person.getFace(personGroupId, personId, persistedFaceId) ⇒ <code>Promise</code>\r\nGet a face for a person.\r\n\r\n**Kind**: static method of <code>[person](#Client.face.person)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | The target person's person group. |\r\n| personId | <code>string</code> | The target person that the face is to get from. |\r\n| persistedFaceId | <code>string</code> | The ID of the face to get. |\r\n\r\n<a name=\"Client.face.person.create\"></a>\r\n\r\n##### person.create(personGroupId, name, userData) ⇒ <code>Promise</code>\r\nCreates a new person in a specified person group for identification.\r\nThe number of persons has a subscription limit. Free subscription amount is 1000 persons.\r\n\r\n**Kind**: static method of <code>[person](#Client.face.person)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | The target person's person group. |\r\n| name | <code>string</code> | Target person's display name. The maximum length is 128. |\r\n| userData | <code>string</code> | Optional fields for user-provided data attached to a person. Size limit is 16KB. |\r\n\r\n<a name=\"Client.face.person.delete\"></a>\r\n\r\n##### person.delete(personGroupId, personId) ⇒ <code>Promise</code>\r\nDeletes an existing person from a person group.\r\n\r\n**Kind**: static method of <code>[person](#Client.face.person)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | The target person's person group. |\r\n| personId | <code>string</code> | The target person to delete. |\r\n\r\n<a name=\"Client.face.person.get\"></a>\r\n\r\n##### person.get(personGroupId, personId) ⇒ <code>Promise</code>\r\nGets an existing person from a person group.\r\n\r\n**Kind**: static method of <code>[person](#Client.face.person)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | The target person's person group. |\r\n| personId | <code>string</code> | The target person to get. |\r\n\r\n<a name=\"Client.face.person.update\"></a>\r\n\r\n##### person.update(personGroupId, name, userData) ⇒ <code>Promise</code>\r\nUpdates a person's information.\r\n\r\n**Kind**: static method of <code>[person](#Client.face.person)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | The target person's person group. |\r\n| name | <code>string</code> | Target person's display name. The maximum length is 128. |\r\n| userData | <code>string</code> | Optional fields for user-provided data attached to a person. Size limit is 16KB. |\r\n\r\n<a name=\"Client.face.person.list\"></a>\r\n\r\n##### person.list(personGroupId) ⇒ <code>Promise</code>\r\nLists all persons in a person group, with the person information.\r\n\r\n**Kind**: static method of <code>[person](#Client.face.person)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| personGroupId | <code>string</code> | The target person's person group. |\r\n\r\n<a name=\"Client.face..detect\"></a>\r\n\r\n#### face~detect(options) ⇒ <code>Promise</code>\r\nCall the Face Detected API\r\nDetects human faces in an image and returns face locations, face landmarks, and\r\noptional attributes including head-pose, gender, and age. Detection is an essential\r\nAPI that provides faceId to other APIs like Identification, Verification,\r\nand Find Similar.\r\n\r\n**Kind**: inner method of <code>[face](#Client.face)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| options | <code>object</code> | Options object |\r\n| options.url | <code>string</code> | URL to image to be used |\r\n| options.path | <code>string</code> | Path to image to be used |\r\n| options.data | <code>string</code> | Image as a binary buffer |\r\n| options.returnFaceId | <code>boolean</code> | Include face ID in response? |\r\n| options.analyzesFaceLandmarks | <code>boolean</code> | Analyze face landmarks? |\r\n| options.analyzesAge | <code>boolean</code> | Analyze age? |\r\n| options.analyzesGender | <code>boolean</code> | Analyze gender? |\r\n| options.analyzesHeadPose | <code>boolean</code> | Analyze headpose? |\r\n| options.analyzesSmile | <code>boolean</code> | Analyze smile? |\r\n| options.analyzesFacialHair | <code>boolean</code> | Analyze facial hair? |\r\n\r\n<a name=\"Client.face..similar\"></a>\r\n\r\n#### face~similar(sourceFace, options) ⇒ <code>Promise</code>\r\nDetect similar faces using faceIds (as returned from the detect API), or faceListId\r\n(as returned from the facelist API).\r\n\r\n**Kind**: inner method of <code>[face](#Client.face)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| sourceFace | <code>string</code> | String of faceId for the source face |\r\n| options | <code>object</code> | Options object |\r\n| options.candidateFaces | <code>Array.&lt;string&gt;</code> | Array of faceIds to use as candidates |\r\n| options.candidateFaceListId | <code>string</code> | Id of face list, created via FaceList.create |\r\n| options.maxCandidates | <code>Number</code> | Optional max number for top candidates (default is 20, max is 20) |\r\n\r\n<a name=\"Client.face..grouping\"></a>\r\n\r\n#### face~grouping(faces) ⇒ <code>Promise</code>\r\nDivides candidate faces into groups based on face similarity using faceIds.\r\nThe output is one or more disjointed face groups and a MessyGroup.\r\nA face group contains the faces that have similar looking, often of the same person.\r\nThere will be one or more face groups ranked by group size, i.e. number of face.\r\nFaces belonging to the same person might be split into several groups in the result.\r\nThe MessyGroup is a special face group that each face is not similar to any other\r\nfaces in original candidate faces. The messyGroup will not appear in the result if\r\nall faces found their similar counterparts. The candidate face list has a\r\nlimit of 100 faces.\r\n\r\n**Kind**: inner method of <code>[face](#Client.face)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| faces | <code>Array.&lt;string&gt;</code> | Array of faceIds to use |\r\n\r\n<a name=\"Client.face..identify\"></a>\r\n\r\n#### face~identify(faces, personGroupId, maxNumOfCandidatesReturned) ⇒ <code>Promise</code>\r\nIdentifies persons from a person group by one or more input faces.\r\nTo recognize which person a face belongs to, Face Identification needs a person group\r\nthat contains number of persons. Each person contains one or more faces. After a person\r\ngroup prepared, it should be trained to make it ready for identification. Then the\r\nidentification API compares the input face to those persons' faces in person group and\r\nreturns the best-matched candidate persons, ranked by confidence.\r\n\r\n**Kind**: inner method of <code>[face](#Client.face)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| faces | <code>Array.&lt;string&gt;</code> | Array of faceIds to use |\r\n| personGroupId | <code>string</code> | Id of person group from which faces will be identified |\r\n| maxNumOfCandidatesReturned | <code>Number</code> | Optional max number of candidates per face (default=1, max=5) |\r\n\r\n<a name=\"Client.face..verify\"></a>\r\n\r\n#### face~verify(faces) ⇒ <code>Promise</code>\r\nAnalyzes two faces and determine whether they are from the same person.\r\nVerification works well for frontal and near-frontal faces.\r\nFor the scenarios that are sensitive to accuracy please use with own judgment.\r\n\r\n**Kind**: inner method of <code>[face](#Client.face)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| faces | <code>Array.&lt;string&gt;</code> | Array containing two faceIds to use |\r\n\r\n<a name=\"Client.text\"></a>\r\n\r\n### Client.text : <code>object</code>\r\n**Kind**: static namespace of <code>[Client](#Client)</code>  \r\n\r\n* [.text](#Client.text) : <code>object</code>\r\n    * [~proof(text, preContextText, postContextText)](#Client.text..proof) ⇒ <code>Promise</code>\r\n    * [~spellCheck(text, preContextText, postContextText)](#Client.text..spellCheck) ⇒ <code>Promise</code>\r\n\r\n<a name=\"Client.text..proof\"></a>\r\n\r\n#### text~proof(text, preContextText, postContextText) ⇒ <code>Promise</code>\r\nProofs a word or phrase.  Offers Microsoft Office Word-like spelling corrections. Longer phrases can\r\nbe checked, and the result will include casing corrections while avoiding aggressive corrections.\r\n\r\n**Kind**: inner method of <code>[text](#Client.text)</code>  \r\n**Returns**: <code>Promise</code> - - A promise in which the resulting JSON is returned.  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| text | <code>string</code> | Word or phrase to spell check. |\r\n| preContextText | <code>string</code> | Optional context of one or more words preceding the target word/phrase. |\r\n| postContextText | <code>string</code> | Optional context of one or more words following the target word/phrase. |\r\n\r\n<a name=\"Client.text..spellCheck\"></a>\r\n\r\n#### text~spellCheck(text, preContextText, postContextText) ⇒ <code>Promise</code>\r\nSpell checks a word or phrase.  Spell checks offers search-engine-like corrections.  Short phrases\r\n(up to 9 tokens) will be checked, and the result will be optimized for search queries, both in terms\r\nof performance and relevance.\r\n\r\n**Kind**: inner method of <code>[text](#Client.text)</code>  \r\n**Returns**: <code>Promise</code> - - A promise in which the resulting JSON is returned.  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| text | <code>string</code> | Word or phrase to spell check. |\r\n| preContextText | <code>string</code> | Optional context of one or more words preceding the target word/phrase. |\r\n| postContextText | <code>string</code> | Optional context of one or more words following the target word/phrase. |\r\n\r\n<a name=\"Client.video\"></a>\r\n\r\n### Client.video : <code>object</code>\r\n**Kind**: static namespace of <code>[Client](#Client)</code>  \r\n\r\n* [.video](#Client.video) : <code>object</code>\r\n    * _static_\r\n        * [.result](#Client.video.result)\r\n            * [.get(operation)](#Client.video.result.get) ⇒ <code>Promise</code>\r\n            * [.getVideo(url, pipe)](#Client.video.result.getVideo) ⇒ <code>Promise</code>\r\n    * _inner_\r\n        * [~trackFace(options)](#Client.video..trackFace) ⇒ <code>Promise</code>\r\n        * [~detectMotion(options)](#Client.video..detectMotion) ⇒ <code>Promise</code>\r\n        * [~stabilize(options)](#Client.video..stabilize) ⇒ <code>Promise</code>\r\n\r\n<a name=\"Client.video.result\"></a>\r\n\r\n#### video.result\r\n**Kind**: static property of <code>[video](#Client.video)</code>  \r\n\r\n* [.result](#Client.video.result)\r\n    * [.get(operation)](#Client.video.result.get) ⇒ <code>Promise</code>\r\n    * [.getVideo(url, pipe)](#Client.video.result.getVideo) ⇒ <code>Promise</code>\r\n\r\n<a name=\"Client.video.result.get\"></a>\r\n\r\n##### result.get(operation) ⇒ <code>Promise</code>\r\nChecks the result of a given operation.  When an operation is deemed completed, the\r\nstatus of the returned object should be 'Succeeded' (or, possibly, 'Failed'.) For\r\noperations which return a JSON payload, the stringified-JSON is returned in the\r\nprocessingResult field.  For operations which return a video, the location of the\r\nvideo is provided in the resourceLocation field.  You can use the [getVideo](Client.video.result#getVideo) method\r\nto help you retrieve that, as this would automatically attach the API key to request.\r\n\r\n**Kind**: static method of <code>[result](#Client.video.result)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| operation | <code>Object</code> | Object holding the result URL |\r\n\r\n<a name=\"Client.video.result.getVideo\"></a>\r\n\r\n##### result.getVideo(url, pipe) ⇒ <code>Promise</code>\r\nDownloads the resulting video, for processors that returning videos instead of metadata.\r\nCurrently this applies to the [stabilize](Client.video#stabilize) operation.\r\n\r\n**Kind**: static method of <code>[result](#Client.video.result)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting video  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| url | <code>string</code> | URL of the resource |\r\n| pipe | <code>Object</code> | Destination for video, typically a fs object |\r\n\r\n<a name=\"Client.video..trackFace\"></a>\r\n\r\n#### video~trackFace(options) ⇒ <code>Promise</code>\r\nStart a face-tracking processor\r\nFaces in a video will be tracked.\r\n\r\n**Kind**: inner method of <code>[video](#Client.video)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| options | <code>object</code> | Options object |\r\n| options.url | <code>string</code> | URL to video to be processed |\r\n| options.path | <code>string</code> | Path to video to be processed |\r\n| options.stream | <code>stream</code> | Stream for video to be processed |\r\n\r\n<a name=\"Client.video..detectMotion\"></a>\r\n\r\n#### video~detectMotion(options) ⇒ <code>Promise</code>\r\nStart a motion-tracking processor\r\nMotion in a video will be tracked.\r\n\r\n**Kind**: inner method of <code>[video](#Client.video)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| options | <code>object</code> | Options object |\r\n| options.url | <code>string</code> | URL to video to be processed |\r\n| options.path | <code>string</code> | Path to video to be processed |\r\n| options.stream | <code>stream</code> | Stream for video to be processed |\r\n\r\n<a name=\"Client.video..stabilize\"></a>\r\n\r\n#### video~stabilize(options) ⇒ <code>Promise</code>\r\nStart a stablization processor\r\nA stabilized version of you video will be generated.\r\n\r\n**Kind**: inner method of <code>[video](#Client.video)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| options | <code>object</code> | Options object |\r\n| options.url | <code>string</code> | URL to video to be processed |\r\n| options.path | <code>string</code> | Path to video to be processed |\r\n| options.stream | <code>stream</code> | Stream for video to be processed |\r\n\r\n<a name=\"Client.vision\"></a>\r\n\r\n### Client.vision : <code>object</code>\r\n**Kind**: static namespace of <code>[Client](#Client)</code>  \r\n\r\n* [.vision](#Client.vision) : <code>object</code>\r\n    * _static_\r\n        * [.models](#Client.vision.models) : <code>object</code>\r\n            * [.list()](#Client.vision.models.list) ⇒ <code>Promise</code>\r\n            * [.analyzeImage(model, options)](#Client.vision.models.analyzeImage) ⇒ <code>Promise</code>\r\n    * _inner_\r\n        * [~analyzeImage(options)](#Client.vision..analyzeImage) ⇒ <code>Promise</code>\r\n        * [~thumbnail(options)](#Client.vision..thumbnail) ⇒ <code>Promise</code>\r\n        * [~ocr(options)](#Client.vision..ocr) ⇒ <code>Promise</code>\r\n\r\n<a name=\"Client.vision.models\"></a>\r\n\r\n#### vision.models : <code>object</code>\r\n**Kind**: static namespace of <code>[vision](#Client.vision)</code>  \r\n\r\n* [.models](#Client.vision.models) : <code>object</code>\r\n    * [.list()](#Client.vision.models.list) ⇒ <code>Promise</code>\r\n    * [.analyzeImage(model, options)](#Client.vision.models.analyzeImage) ⇒ <code>Promise</code>\r\n\r\n<a name=\"Client.vision.models.list\"></a>\r\n\r\n##### models.list() ⇒ <code>Promise</code>\r\nLists the domain-specific image analysis models.\r\n\r\n**Kind**: static method of <code>[models](#Client.vision.models)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n<a name=\"Client.vision.models.analyzeImage\"></a>\r\n\r\n##### models.analyzeImage(model, options) ⇒ <code>Promise</code>\r\nAnalyze an image using a domain-specific image classifier.\r\n\r\n**Kind**: static method of <code>[models](#Client.vision.models)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| model | <code>string</code> | Name of the model |\r\n| options | <code>Object</code> | Options object location of the source image |\r\n| options.url | <code>string</code> | Url to image to be analyzed |\r\n| options.path | <code>string</code> | Path to image to be analyzed |\r\n\r\n<a name=\"Client.vision..analyzeImage\"></a>\r\n\r\n#### vision~analyzeImage(options) ⇒ <code>Promise</code>\r\nThis operation does a deep analysis on the given image and then extracts a\r\nset of rich visual features based on the image content.\r\n\r\n**Kind**: inner method of <code>[vision](#Client.vision)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| options | <code>Object</code> | Options object describing features to extract |\r\n| options.url | <code>string</code> | Url to image to be analyzed |\r\n| options.path | <code>string</code> | Path to image to be analyzed |\r\n| options.ImageType | <code>boolean</code> | Detects if image is clipart or a line drawing. |\r\n| options.Color | <code>boolean</code> | Determines the accent color, dominant color, if image is black&white. |\r\n| options.Faces | <code>boolean</code> | Detects if faces are present. If present, generate coordinates, gender and age. |\r\n| options.Adult | <code>boolean</code> | Detects if image is pornographic in nature (nudity or sex act). Sexually suggestive content is also detected. |\r\n| options.Categories | <code>boolean</code> | Image categorization; taxonomy defined in documentation. |\r\n| options.Tags | <code>boolean</code> | Tags the image with a detailed list of words related to the image content. |\r\n| options.Description | <code>boolean</code> | Describes the image content with a complete English sentence. |\r\n\r\n<a name=\"Client.vision..thumbnail\"></a>\r\n\r\n#### vision~thumbnail(options) ⇒ <code>Promise</code>\r\nGenerate a thumbnail image to the user-specified width and height. By default, the\r\nservice analyzes the image, identifies the region of interest (ROI), and generates\r\nsmart crop coordinates based on the ROI. Smart cropping is designed to help when you\r\nspecify an aspect ratio that differs from the input image.\r\n\r\n**Kind**: inner method of <code>[vision](#Client.vision)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| options | <code>Object</code> | Options object describing features to extract |\r\n| options.url | <code>string</code> | Url to image to be thumbnailed |\r\n| options.path | <code>string</code> | Path to image to be thumbnailed |\r\n| options.width | <code>number</code> | Width of the thumb in pixels |\r\n| options.height | <code>number</code> | Height of the thumb in pixels |\r\n| options.smartCropping | <code>boolean</code> | Should SmartCropping be enabled? |\r\n| options.pipe | <code>Object</code> | We'll pipe the returned image to this object |\r\n\r\n<a name=\"Client.vision..ocr\"></a>\r\n\r\n#### vision~ocr(options) ⇒ <code>Promise</code>\r\nOptical Character Recognition (OCR) detects text in an image and extracts the recognized\r\ncharacters into a machine-usable character stream.\r\n\r\n**Kind**: inner method of <code>[vision](#Client.vision)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| options | <code>Object</code> | Options object describing features to extract |\r\n| options.url | <code>string</code> | Url to image to be analyzed |\r\n| options.path | <code>string</code> | Path to image to be analyzed |\r\n| options.language | <code>string</code> | BCP-47 language code of the text to be detected in the image. Default value is \"unk\", then the service will auto detect the language of the text in the image. |\r\n| options.detectOrientation | <code>string</code> | Detect orientation of text in the image |\r\n\r\n<a name=\"Client.weblm\"></a>\r\n\r\n### Client.weblm : <code>object</code>\r\n**Kind**: static namespace of <code>[Client](#Client)</code>  \r\n\r\n* [.weblm](#Client.weblm) : <code>object</code>\r\n    * [~listModels()](#Client.weblm..listModels) ⇒ <code>Promise</code>\r\n    * [~breakIntoWords(model, text, options)](#Client.weblm..breakIntoWords) ⇒ <code>Promise</code>\r\n    * [~generateWords(model, words, options)](#Client.weblm..generateWords) ⇒ <code>Promise</code>\r\n    * [~getJointProbabilities(model, phrases, order)](#Client.weblm..getJointProbabilities) ⇒ <code>Promise</code>\r\n    * [~getConditionalProbabilities(model, queries, order)](#Client.weblm..getConditionalProbabilities) ⇒ <code>Promise</code>\r\n\r\n<a name=\"Client.weblm..listModels\"></a>\r\n\r\n#### weblm~listModels() ⇒ <code>Promise</code>\r\nList available language models for the service currently.\r\n\r\n**Kind**: inner method of <code>[weblm](#Client.weblm)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n<a name=\"Client.weblm..breakIntoWords\"></a>\r\n\r\n#### weblm~breakIntoWords(model, text, options) ⇒ <code>Promise</code>\r\nBreaks text in to consituent words\r\n\r\n**Kind**: inner method of <code>[weblm](#Client.weblm)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| model | <code>string</code> | Name of model. Currently one of title/anchor/query/body |\r\n| text | <code>string</code> | Text to break.  E.g. onetwothree |\r\n| options | <code>Object</code> | Options object |\r\n| options.order | <code>Number</code> | Optional N-gram order. Default is 5 |\r\n| options.maxCandidates | <code>Number</code> | Optional maximum candidate count. Default is 5 |\r\n\r\n<a name=\"Client.weblm..generateWords\"></a>\r\n\r\n#### weblm~generateWords(model, words, options) ⇒ <code>Promise</code>\r\nGenerates a list of candidate of words that would follow the a given sequence of one or more words\r\n\r\n**Kind**: inner method of <code>[weblm](#Client.weblm)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| model | <code>string</code> | Name of model. Currently one of title/anchor/query/body |\r\n| words | <code>string</code> | Text to break.  E.g. 'hello world wide' |\r\n| options | <code>Object</code> | Options object |\r\n| options.order | <code>Number</code> | Optional N-gram order. Default is 5 |\r\n| options.maxCandidates | <code>Number</code> | Optional maximum candidate count. Default is 5 |\r\n\r\n<a name=\"Client.weblm..getJointProbabilities\"></a>\r\n\r\n#### weblm~getJointProbabilities(model, phrases, order) ⇒ <code>Promise</code>\r\nGenerates a list of candidate of words that would follow the a given sequence of one or more words\r\n\r\n**Kind**: inner method of <code>[weblm](#Client.weblm)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| model | <code>string</code> | Name of model. Currently one of title/anchor/query/body |\r\n| phrases | <code>Array.&lt;string&gt;</code> | One or more phrases for which to look up the probalities of the word sequences |\r\n| order | <code>Number</code> | Optional N-gram order. Default is 5 |\r\n\r\n<a name=\"Client.weblm..getConditionalProbabilities\"></a>\r\n\r\n#### weblm~getConditionalProbabilities(model, queries, order) ⇒ <code>Promise</code>\r\nGenerates a list of candidate of words that would follow the a given sequence of one or more words\r\n\r\n**Kind**: inner method of <code>[weblm](#Client.weblm)</code>  \r\n**Returns**: <code>Promise</code> - - Promise resolving with the resulting JSON  \r\n\r\n| Param | Type | Description |\r\n| --- | --- | --- |\r\n| model | <code>string</code> | Name of model. Currently one of title/anchor/query/body |\r\n| queries | <code>Array</code> | One of more objects consisting of 'words'/'word' pairs,      where the conditional probability of 'word' in the context of 'words' is computed. |\r\n| order | <code>Number</code> | Optional N-gram order. Default is 5 |\r\n\r\nLicensed as MIT - please see LICENSE for details.\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/felixrieseberg/project-oxford/issues"
  },
  "homepage": "https://github.com/felixrieseberg/project-oxford#readme",
  "_id": "project-oxford@1.5.0",
  "_shasum": "c2f80fce98c8f4127d58dc49308262c9d991e2aa",
  "_from": "node_modules\\project-oxford",
  "_resolved": "file:node_modules\\project-oxford"
}
